= Getting Started
include::_attributes.adoc[]
:profile: gitops

An Argo CD instance dedicated for you has been deployed into the OpenShift
Project `userX-argocd`. This is one of the benefits of the Operator-based
mechanism that OpenShift uses: it's easy for users to deploy software and
solutions.

[#review-argocd]
== Review the Argo CD Deployment

In the OpenShift web console, with the _Developer_ perspective active, click the
_Topology_ link in the left navigation and make sure that the `userX-argocd`
Project is selected at the top. You will see the Argo CD deployment in the
topology view:

image::argocd-topology.png[]


[#connect-argocd]
== Connecting to Argo CD

Argo CD generates a default `admin` user and a random password when first
deployed. You can connect to Argo CD using this user account via the CLI or web
console.  In this workshop, we will only use the Argo CD web console.

In your web terminal, you can retrieve the Argo CD admin password from a secret
that is in the same Project as the Argo CD deployment:

[.console-input]
[source,bash,subs="attributes+,+macros"]
----
argoPass=$(oc -n user%USERNUM%-argocd get secret user%USERNUM%-argo-cluster -o jsonpath="{.data.admin\.password}" | base64 -d)
echo $argoPass
----

You _could_ also get this value by using the web console to navigate to the
_Secrets_ menu on the left, finding the `user%USERNUM%-argo-cluster` secret, and
then clicking into it.

There are a few ways to find the URL for your Argo CD instance. In the _Topology_ view of your Project, any Routes/Ingresses associated with
services will have a little pop-out icon:

image::argocd-topology-link.png[]

You can find all of the Routes by clicking the _Project_ link on the left, and
then clicking _Route_ on the subsequent page.

Also, you can get the Argo CD Route using the `oc` CLI:

[.console-input]
[source,bash,subs="attributes+,+macros"]
----
oc get route -n user%USERNUM%-argocd user%USERNUM%-argo-server -o jsonpath='{.spec.host}{"\n"}'
----

However you decide to access the Argo CD console, log in with the username
`admin` and the password extracted in the previous step:

image::argocd-login.png[ArgoCDLogin, 600]

Once you've logged in, you should see the following page. This is the Argo CD
Web UI.

image::argocd-login2.png[ArgoCDLogin2, 600]

[#deploy-sample-application]
== Deploy a Sample Application

As GitOps implies some relationship to Git, we will need to get manifests from a
repository somewhere. You will be using the repository that contains this
workshop and its documentation as the source of the manifests that define the
application state:

https://github.com/OpenShiftDemos/openshift-gitops-workshop/tree/master/documentation/modules/ROOT/examples[https://github.com/OpenShiftDemos/openshift-gitops-workshop/tree/master/documentation/modules/ROOT/examples,window="_blank']

=== Review the Application Manifests

The application manifests include a Deployment, Service, and Route.

[IMPORTANT]
====
Review, but do not apply these manifests to your cluster. You will do that
shortly using Argo CD.
====

*Deployment*:

[source,yaml,subs="+macros,attributes+"]
----
include::ROOT:example$bgd/bgd-deployment.yaml[]
----

A *Service*:

[source,yaml,subs="+macros,attributes+"]
----
include::ROOT:example$bgd/bgd-svc.yaml[]
----

A *Route*:

[source,yaml,subs="+macros,attributes+"]
----
include::ROOT:example$bgd/bgd-route.yaml[]
----

=== Deploy the Application

A managed collection of manifests is known as an `Application` within Argo CD.
Therefore, you must define it as such using an
link:https://argo-cd.readthedocs.io/en/stable/operator-manual/declarative-setup/#applications[Application
CR (CustomResource)^] in order to have Argo CD apply these manifests in your
cluster.

Let's review the Argo CD Application manifest used to deploy this application
and break this down a bit:

[source,yaml,subs="+macros,attributes+"]
----
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: bgd-app
spec:
  destination:
    namespace: bgd
    server: https://kubernetes.default.svc <1>
  project: default <2>
  source: <3>
    path: documentation/modules/ROOT/examples/bgd
    repoURL: https://github.com/redhat-developer-demos/openshift-gitops-examples
    targetRevision: main
  syncPolicy: <4>
    automated:
      prune: true
      selfHeal: false
----
<1> The destination server is API endpoint for the cluster where Argo CD is running -- in this case, using the locally-resolveable URL for the cluster
<2> Here you're installing the application in Argo CD's `default` project (`.spec.project`).
[NOTE]
Argo CD's concept of a `Project` is different than OpenShift's. Here you're installing the application in Argo CD's `default` project (`.spec.project`). *NOT* OpenShift's default project.
<3> The manifest repo, and th path within it where the YAML resides.
<4> The `syncPolicy` is set to `automated`. It will automatically prune resources that have been removed from the Git repo, but will not automatically correct resources that deviate from the definition stored in the repo, i.e manual changes made using `kubectl` will not be "healed".

Apply the Application CR by running the following command:

[.console-input]
[source,bash,subs="attributes+,+macros"]
----
oc apply -n user%USERNUM%-argocd -f documentation/modules/ROOT/examples/bgd-app.yaml
----

The newly created Application appears as a tile with the title `bgd-app` in the Argo CD UI.

image::argocd-app1.png[SampleApp]

Clicking on this tile takes you to the application details page. You may see it as still progressing or fully synced.

image::argocd-app2.png[SampleApp]

NOTE: You may have to click on `show hidden resources` on this page to see all of the resources.

At this point the application should be up and running. Verify that the resources were created:

[.console-input]
[source,bash,subs="attributes+,+macros"]
----
kubectl get all -n bgd
----

The output should list a Service, Deployment, and Pod:

[.console-output]
[source,bash,subs="attributes+,+macros"]
----
NAME                       READY   STATUS    RESTARTS   AGE
pod/bgd-788cb756f7-kz448   1/1     Running   0          10m

NAME          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
service/bgd   ClusterIP   172.30.111.118   <none>        8080/TCP   10m

NAME                  READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/bgd   1/1     1            1           10m
----

Verify the the rollout is complete:

[.console-input]
[source,bash,subs="attributes+,+macros"]
----
kubectl rollout status deploy/bgd -n bgd
----

Obtain the URL, and visit your application in a web browser:


[tabs, subs="attributes+,+macros"]
====
Minikube::
+
--
Add Minikube IP (`minikube ip`) and the Ingress hostname `bgd.devnation` to your Host file, like `/etc/hosts`.

Example:
[source,bash,subs="attributes+,+macros"]
----
192.168.39.242 bgd.devnation
----

--
OpenShift::
+
--
From *Web Console*, select *bgd* project from drop-down menu, then click to the application's Route to access it.

image::bgdapp.png[BGD App]

Alternatively, get app Route from CLI:

[.console-input]
[source,bash,subs="attributes+,+macros"]
----
oc get route bgd -n bgd -o jsonpath='{.spec.host}{"\n"}'
----
--
====

Your application should look like this.

image::bgd.png[SampleApp]

=== Addressing Configuration Drift

Let's introduce a change in the application environment! Patch the live Deployment manifest to change the color
of the bubbles in the application from blue to green:

[.console-input]
[source,bash,subs="attributes+,+macros"]
----
kubectl -n bgd patch deploy/bgd --type='json' -p='[{"op": "replace", "path": "/spec/template/spec/containers/0/env/0/value", "value":"green"}]'
----

Wait for the rollout to happen:

[.console-input]
[source,bash,subs="attributes+,+macros"]
----
kubectl rollout status deploy/bgd -n bgd
----

Refresh the tab where your application is running. You should see green bubbles.

image::bgd-green.png[BDG Green]

Looking over at your Argo CD Web UI, you can see that Argo detects your
application as "Out of Sync".

image::out-of-sync.png[Out of Sync]

You can sync your app via the Argo CD by:

* First clicking `SYNC`
* Then clicking `SYNCHRONIZE`

Alternatively, you can run the following command:

[.console-input]
[source,bash,subs="attributes+,+macros"]
----
argocd app sync bgd-app
----

After the sync process is done, the Argo CD UI should mark the application as in sync.

image::fullysynced.png[Fully Synced]

Reload the page on the tab where the application is running. The bubbles should have returned to their original blue color.

image::bgd.png[BDG App]

You can setup Argo CD to automatically correct drift by setting the
`Application` manifest to do so. Example:

[.console-input]
[source,yaml,subs="attributes+,+macros"]
----
spec:
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
----

Or, as in our case, after the fact by running the following command:

[tabs, subs="attributes+,+macros"]
====
Minikube::
+
--
[.console-input]
[source,bash,subs="attributes+,+macros"]
----
kubectl patch application/bgd-app -n argocd --type=merge -p='{"spec":{"syncPolicy":{"automated":{"prune":true,"selfHeal":true}}}}'
----
--
OpenShift::
+
--
[.console-input]
[source,bash,subs="attributes+,+macros"]
----
kubectl patch application/bgd-app -n openshift-gitops --type=merge -p='{"spec":{"syncPolicy":{"automated":{"prune":true,"selfHeal":true}}}}'
----
--
====

